kind: Template
apiVersion: template.openshift.io/v1
labels:
  app: '${NAME}'
  app.kubernetes.io/component: database
  app.kubernetes.io/instance: '${NAME}'
  app.kubernetes.io/managed-by: template
  app.kubernetes.io/name: patroni
  phase: deploy
metadata:
  name: biohubbc-db-dc
  annotations:
    description: 'Patroni Postgresql database cluster, with persistent storage.'
    iconClass: icon-postgresql
    openshift.io/display-name: Patroni Postgresql (Persistent)
    openshift.io/long-description: >-
      This template deploys a patroni postgresql HA cluster with persistent
      storage.
    tags: postgresql
parameters:
  - name: NAME
    displayName: Application Name
    description: |
      The name of the application for labelling all artifacts.
    value: postgresql
  - name: REPLICAS
    displayName: REPLICAS
    description: |
      The number of StatefulSet replicas to use.
    value: '3'
  - name: IMAGE_STREAM_NAME
    description: |
      The Patroni image stream name
    value: patroni-postgres
  - name: IMAGE_STREAM_NAMESPACE
    displayName: ImageStream Namespace
    description: |
      The OpenShift Namespace where the patroni and postgresql
      ImageStream resides.
    value: af2668-tools
  - name: IMAGE_STREAM_VERSION
    description: |
      The image tag used to specify which image you would like deployed.
      Don't use `latest`.
    value: '12.5'
  - name: DATABASE_SERVICE_NAME
    required: true
    value: 'postgresql'
  - description: Username for PostgreSQL user that will be used for accessing the database.
    displayName: PostgreSQL Connection Username
    name: POSTGRESQL_USER
    required: true
    value: 'postgres'
  - description: Admin Username for PostgreSQL user that will be used for accessing the database.
    displayName: PostgreSQL Admin Connection Username
    name: POSTGRESQL_ADMIN_USER
    required: true
    value: 'postgres'
  - description: Password for the PostgreSQL connection user.
    displayName: PostgreSQL Connection Password
    from: '[a-zA-Z0-9]{16}'
    generate: expression
    name: POSTGRESQL_PASSWORD
    required: true
  - description: Password for the PostgreSQL admin user.
    displayName: PostgreSQL Admin Connection Password
    from: '[a-zA-Z0-9]{16}'
    generate: expression
    name: POSTGRESQL_ADMIN_PASSWORD
    required: true
  - description: Name of the PostgreSQL database accessed.
    displayName: PostgreSQL Database Name
    name: POSTGRESQL_DATABASE
    required: true
    value: 'biohubbc'
  - name: VOLUME_CAPACITY
    displayName: Persistent Volume Size
    description: The size of the persistent volume to create.
    value: 3Gi
  - name: CPU_REQUEST
    displayName: CPU REQUEST
    description: |
      Starting amount of CPU the container can use.
    value: 500m
  - name: CPU_LIMIT
    displayName: CPU Limit
    description: Maximum amount of CPU the container can use.
    value: '3'
  - name: MEMORY_REQUEST
    displayName: Memory Request
    description: Starting amount of memory the container can use.
    value: 2Gi
  - name: MEMORY_LIMIT
    displayName: Memory Limit
    description: Maximum amount of memory the container can use.
    value: 4Gi
  - name: STORAGE_CLASS
    value: netapp-file-standard
  - name: IMAGE_REGISTRY
    value: 'image-registry.openshift-image-registry.svc:5000'
objects:
  - apiVersion: v1
    kind: Secret
    metadata:
      annotations:
        template.openshift.io/expose-database-name: "{.data['database-name']}"
        template.openshift.io/expose-database-user-password: "{.data['database-user-password']}"
        template.openshift.io/expose-app-database-user: "{.data['app-database-user']}"
        template.openshift.io/expose-replication-password: "{.data['replication-password']}"
        template.openshift.io/expose-replication-username: "{.data['replication-username']}"
        template.openshift.io/expose-database-admin-password: "{.data['database-admin-password']}"
        template.openshift.io/expose-database-admin: "{.data['database-admin']}"
        as-copy-of: biohubbc-creds
      name: '${DATABASE_SERVICE_NAME}'
    stringData:
      database-name: ${POSTGRESQL_DATABASE}
      database-user-password: ${POSTGRESQL_PASSWORD}
      database-user: ${POSTGRESQL_USER}
      replication-password: ${POSTGRESQL_PASSWORD}
      replication-username: replication
      database-admin-password: ${POSTGRESQL_ADMIN_PASSWORD}
      database-admin: postgres
      database-user-api: biohub_api
      database-user-api-password: ${POSTGRESQL_PASSWORD}
  - apiVersion: v1
    kind: Service
    metadata:
      creationTimestamp: null
      annotations:
        template.openshift.io/expose-uri: postgres://{.spec.clusterIP}:{.spec.ports[?(.name=="postgresql")].port}
      labels:
        app: '${NAME}'
        cluster-name: '${DATABASE_SERVICE_NAME}'
      name: '${DATABASE_SERVICE_NAME}-master'
    spec:
      ports:
        - port: 5432
          protocol: TCP
          targetPort: 5432
      selector:
        cluster-name: '${DATABASE_SERVICE_NAME}'
        role: master
        app.kubernetes.io/name: patroni
      sessionAffinity: None
      type: ClusterIP
    status:
      loadBalancer: {}
  - apiVersion: apps/v1
    kind: StatefulSet
    metadata:
      creationTimestamp: null
      generation: 3
      labels:
        app: '${NAME}'
        cluster-name: '${NAME}'
      name: '${DATABASE_SERVICE_NAME}'
    spec:
      podManagementPolicy: OrderedReady
      replicas: '${{REPLICAS}}'
      revisionHistoryLimit: 10
      selector:
        matchLabels:
          statefulset: '${DATABASE_SERVICE_NAME}'
      serviceName: '${NAME}'
      template:
        metadata:
          creationTimestamp: null
          labels:
            app: '${NAME}'
            statefulset: '${DATABASE_SERVICE_NAME}'
            cluster-name: '${NAME}'
            app.kubernetes.io/name: patroni
        spec:
          affinity:
            podAntiAffinity:
              requiredDuringSchedulingIgnoredDuringExecution:
                - labelSelector:
                    matchExpressions:
                      - key: statefulset
                        operator: In
                        values:
                          - '${NAME}'
                  topologyKey: kubernetes.io/hostname
          containers:
            - resources:
                requests:
                  cpu: '${CPU_REQUEST}'
                  memory: '${MEMORY_REQUEST}'
                limits:
                  cpu: '${CPU_LIMIT}'
                  memory: '${MEMORY_LIMIT}'
              readinessProbe:
                initialDelaySeconds: 5
                timeoutSeconds: 5
                failureThreshold: 4
                exec:
                  command:
                    - /usr/share/scripts/patroni/health_check.sh
              terminationMessagePath: /dev/termination-log
              name: postgresql
              env:
                - name: POD_IP
                  valueFrom:
                    fieldRef:
                      apiVersion: v1
                      fieldPath: status.podIP
                - name: PATRONI_KUBERNETES_NAMESPACE
                  valueFrom:
                    fieldRef:
                      apiVersion: v1
                      fieldPath: metadata.namespace
                - name: PATRONI_KUBERNETES_LABELS
                  value: >-
                    {"cluster-name": "${NAME}", "app.kubernetes.io/name":
                    "patroni"}
                - name: PATRONI_SUPERUSER_USERNAME
                  valueFrom:
                    secretKeyRef:
                      key: database-admin
                      name: ${DB_SERVICE_NAME}
                - name: PATRONI_SUPERUSER_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      key: database-admin-password
                      name: ${DB_SERVICE_NAME}
                - name: PATRONI_REPLICATION_USERNAME
                  valueFrom:
                    secretKeyRef:
                      key: replication-username
                      name: ${DB_SERVICE_NAME}
                - name: PATRONI_REPLICATION_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      key: replication-password
                      name: ${DB_SERVICE_NAME}
                - name: APP_USER
                  valueFrom:
                    secretKeyRef:
                      key: app-db-username
                      name: ${DB_SERVICE_NAME}
                - name: APP_PASSWORD
                  valueFrom:
                    secretKeyRef:
                      key: database-user-password
                      name: ${DB_SERVICE_NAME}
                - name: APP_DATABASE
                  valueFrom:
                    secretKeyRef:
                      key: database-name
                      name: ${DB_SERVICE_NAME}
                - name: PATRONI_SCOPE
                  value: '${NAME}'
                - name: PATRONI_NAME
                  valueFrom:
                    fieldRef:
                      apiVersion: v1
                      fieldPath: metadata.name
                - name: PATRONI_LOG_LEVEL
                  value: WARNING
                - name: PATRONI_POSTGRESQL_DATA_DIR
                  value: /home/postgres/pgdata/pgroot/data
                - name: PATRONI_POSTGRESQL_PGPASS
                  value: /tmp/pgpass
                - name: PATRONI_POSTGRESQL_LISTEN
                  value: '0.0.0.0:5432'
                - name: PATRONI_RESTAPI_LISTEN
                  value: '0.0.0.0:8008'
              ports:
                - containerPort: 8008
                  protocol: TCP
                - containerPort: 5432
                  protocol: TCP
              imagePullPolicy: Always
              volumeMounts:
                - mountPath: /home/postgres/pgdata
                  name: postgresql
              terminationMessagePolicy: File
              image: >-
                ${IMAGE_REGISTRY}/${IMAGE_STREAM_NAMESPACE}/${IMAGE_STREAM_NAME}:${IMAGE_STREAM_VERSION}
          dnsPolicy: ClusterFirst
          restartPolicy: Always
          schedulerName: default-scheduler
          securityContext: {}
          serviceAccountName: '${NAME}'
          terminationGracePeriodSeconds: 0
      updateStrategy:
        type: RollingUpdate
      volumeClaimTemplates:
        - metadata:
            annotations:
              volume.beta.kubernetes.io/storage-class: '${STORAGE_CLASS}'
            labels:
              app: '${NAME}'
            name: ${DATABASE_SERVICE_NAME}
          spec:
            storageClassName: '${STORAGE_CLASS}'
            accessModes:
              - ReadWriteOnce
            resources:
              requests:
                storage: '${VOLUME_CAPACITY}'

