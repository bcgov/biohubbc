import chai, { expect } from 'chai';
import { describe } from 'mocha';
import { QueryResult } from 'pg';
import sinon from 'sinon';
import sinonChai from 'sinon-chai';
import { getMockDBConnection } from '../__mocks__/db';
import { SampleBlockService } from './sample-block-service';

chai.use(sinonChai);

describe('SubCountService', () => {
  afterEach(() => {
    sinon.restore();
  });

  describe('getSubCountServicesForSurveyId', () => {
    it('should succeed with valid data', async () => {
      const mockResponse = ({
        rows: [
          {
            survey_block_id: 1,
            survey_id: 1,
            name: '',
            description: '',
            create_date: '',
            create_user: 1,
            update_date: '',
            update_user: 1,
            revision_count: 1,
            sample_block_count: 1
          }
        ],
        rowCount: 1
      } as any) as Promise<QueryResult<any>>;
      const dbConnection = getMockDBConnection({
        sql: () => mockResponse
      });

      const service = new SubCountService(dbConnection);
      const response = await service.getSubCountServicesForSurveyId(1);

      response.forEach((item) => {
        expect(item.survey_id).to.be.eql(1);
      });
    });

    it('should succeed with empty data', async () => {
      const mockResponse = ({
        rows: [],
        rowCount: 0
      } as any) as Promise<QueryResult<any>>;
      const dbConnection = getMockDBConnection({
        sql: () => mockResponse
      });

      const service = new SubCountService(dbConnection);
      const response = await service.getSubCountServicesForSurveyId(1);
      expect(response).to.be.empty;
    });
  });

  describe('upsertSubCountServices', () => {
    it('should succeed with valid data', async () => {
      const dbConnection = getMockDBConnection();
      const service = new SubCountService(dbConnection);

      const getOldBlocks = sinon.stub(SubCountService.prototype, 'getSubCountServicesForSurveyId').resolves([]);
      const deleteBlock = sinon.stub(SubCountService.prototype, 'deleteSubCountService').resolves();
      const insertBlock = sinon.stub(SubCountServiceRepository.prototype, 'insertSubCountService').resolves();
      const updateBlock = sinon.stub(SubCountServiceRepository.prototype, 'updateSubCountService').resolves();

      const blocks: PostSubCountService[] = [
        { survey_block_id: null, survey_id: 1, name: 'Old Block', description: 'Updated' },
        { survey_block_id: null, survey_id: 1, name: 'New Block', description: 'block' }
      ];
      await service.upsertSubCountServices(1, blocks);

      expect(getOldBlocks).to.be.calledOnce;
      expect(insertBlock).to.be.calledTwice;
      expect(deleteBlock).to.not.be.calledOnce;
      expect(updateBlock).to.not.be.calledOnce;
    });

    it('should run delete block code', async () => {
      const dbConnection = getMockDBConnection();
      const service = new SubCountService(dbConnection);

      const getOldBlocks = sinon.stub(SubCountService.prototype, 'getSubCountServicesForSurveyId').resolves([
        {
          sample_block_count: 0,
          survey_block_id: 10,
          survey_id: 1,
          name: 'Old Block',
          description: 'Updated',
          create_date: '',
          create_user: 1,
          update_date: '',
          update_user: 1,
          revision_count: 1
        },
        {
          sample_block_count: 0,
          survey_block_id: 11,
          survey_id: 1,
          name: 'Old Block',
          description: 'Going to be deleted',
          create_date: '',
          create_user: 1,
          update_date: '',
          update_user: 1,
          revision_count: 1
        }
      ]);
      const deleteBlock = sinon.stub(SubCountService.prototype, 'deleteSubCountService').resolves();
      const insertBlock = sinon.stub(SubCountServiceRepository.prototype, 'insertSubCountService').resolves();
      const updateBlock = sinon.stub(SubCountServiceRepository.prototype, 'updateSubCountService').resolves();

      const blocks: PostSubCountService[] = [
        { survey_block_id: 10, survey_id: 1, name: 'Old Block', description: 'Updated' },
        { survey_block_id: null, survey_id: 1, name: 'New Block', description: 'block' }
      ];
      await service.upsertSubCountServices(1, blocks);

      expect(getOldBlocks).to.be.calledOnce;
      expect(deleteBlock).to.be.calledOnce;
      expect(insertBlock).to.be.calledOnce;
      expect(updateBlock).to.be.calledOnce;
    });
  });

  describe('deleteSubCountService', () => {
    it('should succeed with valid data', async () => {
      const mockResponse = {
        survey_block_id: 1,
        survey_id: 1,
        name: 'Deleted record',
        description: '',
        create_date: '',
        create_user: 1,
        update_date: '',
        update_user: 1,
        revision_count: 1
      };

      const deleteSampleBlockRecordsByBlockIdsStub = sinon
        .stub(SampleBlockService.prototype, 'deleteSampleBlockRecordsByBlockIds')
        .resolves(undefined);

      const deleteSubCountServiceRecordStub = sinon
        .stub(SubCountServiceRepository.prototype, 'deleteSubCountServiceRecord')
        .resolves(mockResponse);

      const dbConnection = getMockDBConnection();

      const service = new SubCountService(dbConnection);
      const subCountServiceId = 1;
      const response = await service.deleteSubCountService(subCountServiceId);

      expect(response).to.eql(mockResponse);
      expect(deleteSampleBlockRecordsByBlockIdsStub).to.have.been.calledOnceWith([subCountServiceId]);
      expect(deleteSubCountServiceRecordStub).to.have.been.calledOnceWith(subCountServiceId);
    });
  });
});
